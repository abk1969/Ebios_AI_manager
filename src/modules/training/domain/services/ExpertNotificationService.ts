/**
 * üîî SERVICE DE NOTIFICATIONS EXPERTES EBIOS RM
 * Notifications intelligentes adapt√©es aux experts GRC/auditeurs
 * POINT 2 - Syst√®me de Notifications Intelligentes A2A
 */

import { EbiosExpertProfile } from '../../../../infrastructure/a2a/types/AgentCardTypes';
import { EbiosNotification, NotificationType, NotificationCategory, NotificationPriority } from '../../../../types/notifications';
import { ExpertiseLevel } from './AdaptiveContentService';

// üéØ TYPES POUR NOTIFICATIONS EXPERTES

export interface ExpertNotificationRequest {
  userId: string;
  userProfile: EbiosExpertProfile;
  expertiseLevel: ExpertiseLevel;
  context: NotificationContext;
  trigger: NotificationTrigger;
  urgency: 'immediate' | 'scheduled' | 'batch';
}

export interface NotificationContext {
  workshopId: number;
  moduleId: string;
  currentStep: string;
  progressPercentage: number;
  timeSpent: number;
  lastActivity: Date;
  sessionId: string;
  adaptationsApplied: number;
  engagementScore: number;
}

export interface NotificationTrigger {
  type: 'progress_milestone' | 'methodology_alert' | 'expert_insight' | 'collaboration_request' | 'quality_check' | 'time_management' | 'cross_workshop_coherence';
  severity: 'info' | 'warning' | 'critical';
  data: Record<string, any>;
  autoGenerated: boolean;
}

export interface ExpertNotificationTemplate {
  id: string;
  name: string;
  expertiseLevel: ExpertiseLevel['level'][];
  sectors: string[];
  titleTemplate: string;
  messageTemplate: string;
  actionTemplate: ExpertActionTemplate[];
  contextualInsights: string[];
  methodologicalGuidance: string[];
}

export interface ExpertActionTemplate {
  id: string;
  label: string;
  type: 'navigation' | 'validation' | 'correction' | 'enhancement' | 'collaboration';
  targetScreen?: string;
  parameters?: Record<string, any>;
  expertLevel: 'all' | 'intermediate' | 'senior' | 'expert' | 'master';
}

export interface NotificationMetrics {
  totalSent: number;
  readRate: number;
  actionRate: number;
  dismissalRate: number;
  averageResponseTime: number;
  effectivenessScore: number;
  userSatisfaction: number;
}

// üîî SERVICE PRINCIPAL DE NOTIFICATIONS EXPERTES

export class ExpertNotificationService {
  private static instance: ExpertNotificationService;
  private notificationTemplates: Map<string, ExpertNotificationTemplate> = new Map();
  private notificationHistory: Map<string, EbiosNotification[]> = new Map();
  private metrics: Map<string, NotificationMetrics> = new Map();
  private activeNotifications: Map<string, EbiosNotification[]> = new Map();

  private constructor() {
    this.initializeExpertTemplates();
  }

  public static getInstance(): ExpertNotificationService {
    if (!ExpertNotificationService.instance) {
      ExpertNotificationService.instance = new ExpertNotificationService();
    }
    return ExpertNotificationService.instance;
  }

  // üéØ G√âN√âRATION DE NOTIFICATIONS EXPERTES

  public async generateExpertNotification(
    request: ExpertNotificationRequest
  ): Promise<EbiosNotification> {
    
    console.log(`üîî G√©n√©ration notification experte pour ${request.userProfile.name}`);
    
    // 1. S√©lection du template appropri√©
    const template = await this.selectOptimalTemplate(request);
    
    // 2. Adaptation du contenu selon le profil expert
    const adaptedContent = await this.adaptContentForExpert(template, request);
    
    // 3. G√©n√©ration des actions contextuelles
    const expertActions = await this.generateExpertActions(template, request);
    
    // 4. Cr√©ation de la notification
    const notification: EbiosNotification = {
      id: `expert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: this.determineNotificationType(request.trigger),
      category: 'workshop' as NotificationCategory,
      priority: this.determinePriority(request.trigger, request.expertiseLevel),
      status: 'unread',
      
      title: adaptedContent.title,
      message: adaptedContent.message,
      description: adaptedContent.description,
      icon: this.getExpertIcon(request.trigger.type),
      
      actions: expertActions,
      primaryAction: expertActions.find(a => a.isPrimary),
      
      context: {
        workshopId: request.context.workshopId,
        moduleId: request.context.moduleId,
        userId: request.userId,
        sessionId: request.context.sessionId,
        metadata: {
          expertiseLevel: request.expertiseLevel.level,
          trigger: request.trigger.type,
          adaptationsApplied: request.context.adaptationsApplied,
          engagementScore: request.context.engagementScore
        }
      },
      
      createdAt: new Date().toISOString(),
      source: 'expert_notification_service',
      tags: [
        'expert',
        'workshop1',
        request.expertiseLevel.level,
        request.trigger.type,
        request.userProfile.sector || 'general'
      ]
    };

    // 5. Stockage et suivi
    await this.storeNotification(request.userId, notification);
    await this.updateMetrics(request.userId, notification);

    console.log(`‚úÖ Notification experte g√©n√©r√©e: ${notification.id}`);
    return notification;
  }

  // üé® S√âLECTION DE TEMPLATE OPTIMAL

  private async selectOptimalTemplate(
    request: ExpertNotificationRequest
  ): Promise<ExpertNotificationTemplate> {
    
    const candidates = Array.from(this.notificationTemplates.values()).filter(template => {
      // Filtrage par niveau d'expertise
      if (!template.expertiseLevel.includes(request.expertiseLevel.level)) {
        return false;
      }
      
      // Filtrage par secteur
      if (template.sectors.length > 0 && request.userProfile.sector) {
        if (!template.sectors.includes(request.userProfile.sector)) {
          return false;
        }
      }
      
      return true;
    });

    if (candidates.length === 0) {
      return this.getDefaultTemplate(request.expertiseLevel.level);
    }

    // S√©lection du template le plus appropri√©
    return candidates.reduce((best, current) => {
      const bestScore = this.calculateTemplateScore(best, request);
      const currentScore = this.calculateTemplateScore(current, request);
      return currentScore > bestScore ? current : best;
    });
  }

  private calculateTemplateScore(
    template: ExpertNotificationTemplate,
    request: ExpertNotificationRequest
  ): number {
    let score = 0;

    // Score selon niveau d'expertise
    if (template.expertiseLevel.includes(request.expertiseLevel.level)) {
      score += 50;
    }

    // Score selon secteur
    if (request.userProfile.sector && template.sectors.includes(request.userProfile.sector)) {
      score += 30;
    }

    // Score selon sp√©cialisations
    const userSpecializations = request.userProfile.specializations || [];
    const templateRelevance = template.contextualInsights.some(insight =>
      userSpecializations.some(spec => insight.toLowerCase().includes(spec))
    );
    if (templateRelevance) {
      score += 20;
    }

    return score;
  }

  // üéØ ADAPTATION DE CONTENU POUR EXPERTS

  private async adaptContentForExpert(
    template: ExpertNotificationTemplate,
    request: ExpertNotificationRequest
  ): Promise<{
    title: string;
    message: string;
    description?: string;
  }> {
    
    const variables = {
      userName: request.userProfile.name,
      userRole: request.userProfile.role,
      expertiseLevel: request.expertiseLevel.level,
      workshopId: request.context.workshopId,
      moduleId: request.context.moduleId,
      currentStep: request.context.currentStep,
      progressPercentage: request.context.progressPercentage,
      sector: request.userProfile.sector || 'g√©n√©ral',
      experience: request.userProfile.experience?.ebiosYears || 0,
      certifications: request.userProfile.certifications?.join(', ') || 'Aucune',
      specializations: request.userProfile.specializations?.join(', ') || 'G√©n√©raliste'
    };

    // Remplacement des variables dans les templates
    let title = this.replaceVariables(template.titleTemplate, variables);
    let message = this.replaceVariables(template.messageTemplate, variables);

    // Adaptation selon le niveau d'expertise
    switch (request.expertiseLevel.level) {
      case 'master':
        title = `üéì ${title}`;
        message = this.enhanceForMaster(message, request);
        break;
      case 'expert':
        title = `üèÜ ${title}`;
        message = this.enhanceForExpert(message, request);
        break;
      case 'senior':
        title = `üë®‚Äçüíº ${title}`;
        message = this.enhanceForSenior(message, request);
        break;
      default:
        title = `üìö ${title}`;
        message = this.enhanceForIntermediate(message, request);
    }

    // G√©n√©ration de description contextuelle
    const description = await this.generateContextualDescription(template, request);

    return { title, message, description };
  }

  private replaceVariables(template: string, variables: Record<string, any>): string {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      result = result.replace(regex, String(value));
    }
    return result;
  }

  private enhanceForMaster(message: string, request: ExpertNotificationRequest): string {
    const enhancements = [
      `\n\nüéØ **Perspective Ma√Ætre :** Votre expertise de ${request.userProfile.experience?.ebiosYears} ans vous permet d'identifier les subtilit√©s m√©thodologiques avanc√©es.`,
      `\nüí° **Insight Expert :** Consid√©rez l'impact sur la gouvernance globale du risque.`
    ];
    
    return message + enhancements.join('');
  }

  private enhanceForExpert(message: string, request: ExpertNotificationRequest): string {
    const enhancements = [
      `\n\nüîç **Analyse Experte :** Votre profil ${request.userProfile.role} vous positionne id√©alement pour cette validation.`,
      `\nüìä **Recommandation :** Appliquez votre expertise sectorielle ${request.userProfile.sector}.`
    ];
    
    return message + enhancements.join('');
  }

  private enhanceForSenior(message: string, request: ExpertNotificationRequest): string {
    const enhancements = [
      `\n\nüë• **Guidance Senior :** Votre exp√©rience peut b√©n√©ficier √† l'√©quipe projet.`,
      `\nüéØ **Focus :** Concentrez-vous sur les aspects m√©thodologiques cl√©s.`
    ];
    
    return message + enhancements.join('');
  }

  private enhanceForIntermediate(message: string, request: ExpertNotificationRequest): string {
    const enhancements = [
      `\n\nüìö **Support :** Des ressources compl√©mentaires sont disponibles.`,
      `\nü§ù **Assistance :** N'h√©sitez pas √† solliciter l'aide d'experts seniors.`
    ];
    
    return message + enhancements.join('');
  }

  private async generateContextualDescription(
    template: ExpertNotificationTemplate,
    request: ExpertNotificationRequest
  ): Promise<string> {
    
    const insights = template.contextualInsights.filter(insight => {
      // Filtrer les insights pertinents selon le contexte
      return insight.toLowerCase().includes(request.userProfile.sector?.toLowerCase() || '') ||
             insight.toLowerCase().includes(request.expertiseLevel.level);
    });

    const guidance = template.methodologicalGuidance.filter(guide => {
      // Filtrer la guidance selon le niveau
      return request.expertiseLevel.level === 'master' || 
             request.expertiseLevel.level === 'expert' ||
             guide.includes('standard');
    });

    let description = '';
    
    if (insights.length > 0) {
      description += `**Insights Contextuels :**\n${insights.slice(0, 2).map(i => `‚Ä¢ ${i}`).join('\n')}\n\n`;
    }
    
    if (guidance.length > 0) {
      description += `**Guidance M√©thodologique :**\n${guidance.slice(0, 2).map(g => `‚Ä¢ ${g}`).join('\n')}`;
    }

    return description;
  }

  // üéÆ G√âN√âRATION D'ACTIONS EXPERTES

  private async generateExpertActions(
    template: ExpertNotificationTemplate,
    request: ExpertNotificationRequest
  ): Promise<any[]> {
    
    const actions = [];
    
    // Actions selon le template
    for (const actionTemplate of template.actionTemplate) {
      if (this.isActionApplicable(actionTemplate, request.expertiseLevel.level)) {
        actions.push({
          id: actionTemplate.id,
          label: actionTemplate.label,
          type: actionTemplate.type,
          isPrimary: actionTemplate.type === 'navigation',
          onClick: () => this.handleExpertAction(actionTemplate, request),
          metadata: {
            targetScreen: actionTemplate.targetScreen,
            parameters: actionTemplate.parameters
          }
        });
      }
    }

    // Actions contextuelles selon le trigger
    const contextualActions = await this.generateContextualActions(request);
    actions.push(...contextualActions);

    return actions.slice(0, 4); // Limiter √† 4 actions max
  }

  private isActionApplicable(
    actionTemplate: ExpertActionTemplate,
    expertiseLevel: string
  ): boolean {
    if (actionTemplate.expertLevel === 'all') return true;
    
    const levelHierarchy = ['junior', 'intermediate', 'senior', 'expert', 'master'];
    const userLevelIndex = levelHierarchy.indexOf(expertiseLevel);
    const requiredLevelIndex = levelHierarchy.indexOf(actionTemplate.expertLevel);
    
    return userLevelIndex >= requiredLevelIndex;
  }

  private async generateContextualActions(
    request: ExpertNotificationRequest
  ): Promise<any[]> {
    
    const actions = [];
    
    // Action selon le trigger
    switch (request.trigger.type) {
      case 'methodology_alert':
        actions.push({
          id: 'review_methodology',
          label: 'R√©viser la M√©thodologie',
          type: 'validation',
          isPrimary: true,
          onClick: () => this.navigateToMethodologyReview(request)
        });
        break;
        
      case 'expert_insight':
        actions.push({
          id: 'view_insights',
          label: 'Consulter les Insights',
          type: 'enhancement',
          isPrimary: false,
          onClick: () => this.showExpertInsights(request)
        });
        break;
        
      case 'collaboration_request':
        actions.push({
          id: 'join_collaboration',
          label: 'Rejoindre la Collaboration',
          type: 'collaboration',
          isPrimary: true,
          onClick: () => this.joinCollaboration(request)
        });
        break;
    }

    return actions;
  }

  // üîß M√âTHODES UTILITAIRES

  private determineNotificationType(trigger: NotificationTrigger): NotificationType {
    switch (trigger.type) {
      case 'progress_milestone': return 'success';
      case 'methodology_alert': return 'warning';
      case 'expert_insight': return 'info';
      case 'collaboration_request': return 'action';
      case 'quality_check': return 'warning';
      case 'time_management': return 'reminder';
      case 'cross_workshop_coherence': return 'warning';
      default: return 'info';
    }
  }

  private determinePriority(
    trigger: NotificationTrigger,
    expertiseLevel: ExpertiseLevel
  ): NotificationPriority {
    if (trigger.severity === 'critical') return 'urgent';
    if (trigger.severity === 'warning') return 'high';
    
    // Priorit√© selon niveau d'expertise
    if (expertiseLevel.level === 'master' || expertiseLevel.level === 'expert') {
      return 'medium'; // Experts g√®rent leur priorit√©
    }
    
    return 'high'; // Plus de guidance pour niveaux inf√©rieurs
  }

  private getExpertIcon(triggerType: string): string {
    const icons = {
      'progress_milestone': 'üéØ',
      'methodology_alert': '‚ö†Ô∏è',
      'expert_insight': 'üí°',
      'collaboration_request': 'ü§ù',
      'quality_check': 'üîç',
      'time_management': '‚è∞',
      'cross_workshop_coherence': 'üîó'
    };
    
    return icons[triggerType] || 'üìã';
  }

  // üíæ STOCKAGE ET M√âTRIQUES

  private async storeNotification(userId: string, notification: EbiosNotification): Promise<void> {
    if (!this.notificationHistory.has(userId)) {
      this.notificationHistory.set(userId, []);
    }
    
    const history = this.notificationHistory.get(userId)!;
    history.push(notification);
    
    // Garder seulement les 100 derni√®res notifications
    if (history.length > 100) {
      history.shift();
    }

    // Ajouter aux notifications actives
    if (!this.activeNotifications.has(userId)) {
      this.activeNotifications.set(userId, []);
    }
    this.activeNotifications.get(userId)!.push(notification);
  }

  private async updateMetrics(userId: string, notification: EbiosNotification): Promise<void> {
    if (!this.metrics.has(userId)) {
      this.metrics.set(userId, {
        totalSent: 0,
        readRate: 0,
        actionRate: 0,
        dismissalRate: 0,
        averageResponseTime: 0,
        effectivenessScore: 0,
        userSatisfaction: 0
      });
    }
    
    const userMetrics = this.metrics.get(userId)!;
    userMetrics.totalSent++;
  }

  // üéØ ACTIONS EXPERTES

  private async handleExpertAction(
    actionTemplate: ExpertActionTemplate,
    request: ExpertNotificationRequest
  ): Promise<void> {
    console.log(`üéØ Action experte: ${actionTemplate.label} pour ${request.userProfile.name}`);
    
    // Logique d'action selon le type
    switch (actionTemplate.type) {
      case 'navigation':
        await this.navigateToTarget(actionTemplate.targetScreen, actionTemplate.parameters);
        break;
      case 'validation':
        await this.performValidation(actionTemplate.parameters, request);
        break;
      case 'correction':
        await this.performCorrection(actionTemplate.parameters, request);
        break;
      case 'enhancement':
        await this.performEnhancement(actionTemplate.parameters, request);
        break;
      case 'collaboration':
        await this.initiateCollaboration(actionTemplate.parameters, request);
        break;
    }
  }

  private async navigateToTarget(targetScreen?: string, parameters?: Record<string, any>): Promise<void> {
    console.log(`üß≠ Navigation vers: ${targetScreen}`, parameters);
  }

  private async performValidation(parameters?: Record<string, any>, request?: ExpertNotificationRequest): Promise<void> {
    console.log(`‚úÖ Validation experte`, parameters);
  }

  private async performCorrection(parameters?: Record<string, any>, request?: ExpertNotificationRequest): Promise<void> {
    console.log(`üîß Correction experte`, parameters);
  }

  private async performEnhancement(parameters?: Record<string, any>, request?: ExpertNotificationRequest): Promise<void> {
    console.log(`‚ö° Am√©lioration experte`, parameters);
  }

  private async initiateCollaboration(parameters?: Record<string, any>, request?: ExpertNotificationRequest): Promise<void> {
    console.log(`ü§ù Collaboration experte`, parameters);
  }

  private async navigateToMethodologyReview(request: ExpertNotificationRequest): Promise<void> {
    console.log(`üìö R√©vision m√©thodologique pour ${request.userProfile.name}`);
  }

  private async showExpertInsights(request: ExpertNotificationRequest): Promise<void> {
    console.log(`üí° Insights experts pour ${request.userProfile.name}`);
  }

  private async joinCollaboration(request: ExpertNotificationRequest): Promise<void> {
    console.log(`ü§ù Rejoindre collaboration pour ${request.userProfile.name}`);
  }

  // üìä API PUBLIQUE

  public getNotificationHistory(userId: string): EbiosNotification[] {
    return this.notificationHistory.get(userId) || [];
  }

  public getActiveNotifications(userId: string): EbiosNotification[] {
    return this.activeNotifications.get(userId) || [];
  }

  public getMetrics(userId: string): NotificationMetrics | null {
    return this.metrics.get(userId) || null;
  }

  public async markAsRead(userId: string, notificationId: string): Promise<void> {
    const activeNotifications = this.activeNotifications.get(userId) || [];
    const notification = activeNotifications.find(n => n.id === notificationId);
    
    if (notification) {
      notification.status = 'read';
      notification.readAt = new Date().toISOString();
      
      // Mettre √† jour les m√©triques
      const metrics = this.metrics.get(userId);
      if (metrics) {
        const totalNotifications = this.notificationHistory.get(userId)?.length || 1;
        const readNotifications = this.notificationHistory.get(userId)?.filter(n => n.readAt).length || 0;
        metrics.readRate = (readNotifications / totalNotifications) * 100;
      }
    }
  }

  // üé® INITIALISATION DES TEMPLATES

  private initializeExpertTemplates(): void {
    // Template pour jalons de progression
    this.notificationTemplates.set('progress_milestone', {
      id: 'progress_milestone',
      name: 'Jalon de Progression Expert',
      expertiseLevel: ['intermediate', 'senior', 'expert', 'master'],
      sectors: [],
      titleTemplate: 'Jalon {{progressPercentage}}% - {{moduleId}}',
      messageTemplate: 'F√©licitations {{userName}} ! Vous avez atteint {{progressPercentage}}% de progression dans le module {{moduleId}}.',
      actionTemplate: [
        {
          id: 'continue_module',
          label: 'Continuer le Module',
          type: 'navigation',
          targetScreen: '/workshop/{{workshopId}}/{{moduleId}}',
          expertLevel: 'all'
        },
        {
          id: 'review_progress',
          label: 'R√©viser la Progression',
          type: 'validation',
          expertLevel: 'senior'
        }
      ],
      contextualInsights: [
        'Votre progression est conforme aux standards EBIOS RM',
        'Les experts de votre niveau compl√®tent g√©n√©ralement cette √©tape en {{timeEstimate}} minutes'
      ],
      methodologicalGuidance: [
        'V√©rifiez la coh√©rence avec les livrables pr√©c√©dents',
        'Documentez les d√©cisions m√©thodologiques importantes'
      ]
    });

    // Template pour alertes m√©thodologiques
    this.notificationTemplates.set('methodology_alert', {
      id: 'methodology_alert',
      name: 'Alerte M√©thodologique Expert',
      expertiseLevel: ['senior', 'expert', 'master'],
      sectors: [],
      titleTemplate: 'Alerte M√©thodologique - {{currentStep}}',
      messageTemplate: 'Attention {{userName}}, une incoh√©rence m√©thodologique a √©t√© d√©tect√©e dans {{currentStep}}.',
      actionTemplate: [
        {
          id: 'review_methodology',
          label: 'R√©viser la M√©thodologie',
          type: 'validation',
          targetScreen: '/methodology/review',
          expertLevel: 'senior'
        },
        {
          id: 'expert_consultation',
          label: 'Consulter un Expert',
          type: 'collaboration',
          expertLevel: 'intermediate'
        }
      ],
      contextualInsights: [
        'Cette alerte est bas√©e sur les bonnes pratiques ANSSI',
        'Votre expertise {{expertiseLevel}} vous permet de r√©soudre ce type d\'incoh√©rence'
      ],
      methodologicalGuidance: [
        'R√©f√©rez-vous au guide EBIOS RM section {{sectionReference}}',
        'V√©rifiez l\'alignement avec les exigences {{sector}}'
      ]
    });

    // Ajouter d'autres templates...
    this.addMoreExpertTemplates();
  }

  private addMoreExpertTemplates(): void {
    // Template pour insights experts
    this.notificationTemplates.set('expert_insight', {
      id: 'expert_insight',
      name: 'Insight Expert Contextuel',
      expertiseLevel: ['expert', 'master'],
      sectors: ['sant√©', 'finance', '√©nergie'],
      titleTemplate: 'Insight Expert - {{sector}}',
      messageTemplate: 'Bas√© sur votre expertise {{sector}}, voici un insight contextuel pour {{currentStep}}.',
      actionTemplate: [
        {
          id: 'apply_insight',
          label: 'Appliquer l\'Insight',
          type: 'enhancement',
          expertLevel: 'expert'
        },
        {
          id: 'share_insight',
          label: 'Partager avec l\'√âquipe',
          type: 'collaboration',
          expertLevel: 'expert'
        }
      ],
      contextualInsights: [
        'Cet insight est sp√©cifique au secteur {{sector}}',
        'Votre exp√©rience de {{experience}} ans enrichit cette analyse'
      ],
      methodologicalGuidance: [
        'Int√©grez cet insight dans votre analyse de risque',
        'Documentez l\'impact sur les sc√©narios de menace'
      ]
    });
  }

  private getDefaultTemplate(expertiseLevel: string): ExpertNotificationTemplate {
    return {
      id: 'default',
      name: 'Notification Standard',
      expertiseLevel: [expertiseLevel as any],
      sectors: [],
      titleTemplate: 'Notification EBIOS RM',
      messageTemplate: 'Une notification importante vous attend.',
      actionTemplate: [
        {
          id: 'view_details',
          label: 'Voir les D√©tails',
          type: 'navigation',
          expertLevel: 'all'
        }
      ],
      contextualInsights: [],
      methodologicalGuidance: []
    };
  }
}

export default ExpertNotificationService;
