/**
 * ðŸ¤– RÃˆGLES MÃ‰TIER POUR NOTIFICATIONS INTELLIGENTES
 * SystÃ¨me de rÃ¨gles pour gÃ©nÃ©rer automatiquement des notifications contextuelles
 */

import { 
  NotificationRule, 
  NotificationTemplate, 
  NotificationPriority,
  NotificationCategory 
} from '../types/notifications';
import { ALL_TEMPLATES } from './NotificationTemplates';

// ðŸŽ¯ TYPES D'Ã‰VÃ‰NEMENTS DÃ‰CLENCHEURS
export interface TriggerEvent {
  type: string;
  source: string;
  userId: string;
  sessionId?: string;
  missionId?: string;
  workshopId?: number;
  data: Record<string, any>;
  timestamp: string;
}

// ðŸŽ¯ CONDITIONS DE DÃ‰CLENCHEMENT
export interface TriggerCondition {
  field: string;
  operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains' | 'exists' | 'in_range';
  value: any;
  optional?: boolean;
}

// ðŸŽ¯ RÃˆGLES DE FORMATION EBIOS RM
export const FORMATION_RULES: NotificationRule[] = [
  {
    id: 'workshop_completion_celebration',
    name: 'CÃ©lÃ©bration Fin d\'Atelier',
    description: 'FÃ©licite l\'utilisateur Ã  la fin d\'un atelier avec suggestions',
    enabled: true,
    trigger: {
      event: 'workshop_completed',
      conditions: {
        score: { operator: 'greater_than', value: 0 }
      }
    },
    template: ALL_TEMPLATES.WORKSHOP_COMPLETED,
    cooldown: 0, // Pas de cooldown pour les cÃ©lÃ©brations
    maxPerDay: 10,
    targetUsers: [] // Tous les utilisateurs
  },

  {
    id: 'validation_error_immediate',
    name: 'Erreur de Validation ImmÃ©diate',
    description: 'Alerte immÃ©diate en cas d\'erreur de validation critique',
    enabled: true,
    trigger: {
      event: 'validation_error',
      conditions: {
        severity: { operator: 'in', value: ['high', 'critical'] }
      }
    },
    template: ALL_TEMPLATES.WORKSHOP_VALIDATION_ERROR,
    cooldown: 300000, // 5 minutes entre erreurs similaires
    maxPerDay: 20,
    targetUsers: []
  },

  {
    id: 'inactivity_reminder_progressive',
    name: 'Rappel d\'InactivitÃ© Progressif',
    description: 'Rappels progressifs selon la durÃ©e d\'inactivitÃ©',
    enabled: true,
    trigger: {
      event: 'user_inactive',
      conditions: {
        days_inactive: { operator: 'greater_than', value: 3 }
      }
    },
    template: ALL_TEMPLATES.INACTIVITY_REMINDER,
    cooldown: 86400000, // 24h entre rappels
    maxPerDay: 1,
    targetUsers: []
  },

  {
    id: 'perfect_score_achievement',
    name: 'Achievement Score Parfait',
    description: 'RÃ©compense pour un score parfait',
    enabled: true,
    trigger: {
      event: 'workshop_completed',
      conditions: {
        score: { operator: 'equals', value: 100 }
      }
    },
    template: ALL_TEMPLATES.PERFECT_SCORE,
    cooldown: 0,
    maxPerDay: 5,
    targetUsers: []
  },

  {
    id: 'first_workshop_milestone',
    name: 'Milestone Premier Atelier',
    description: 'CÃ©lÃ©bration du premier atelier terminÃ©',
    enabled: true,
    trigger: {
      event: 'workshop_completed',
      conditions: {
        workshop_id: { operator: 'equals', value: 1 },
        user_workshop_count: { operator: 'equals', value: 1 }
      }
    },
    template: ALL_TEMPLATES.FIRST_WORKSHOP_COMPLETED,
    cooldown: 0,
    maxPerDay: 1,
    targetUsers: []
  }
];

// ðŸŽ¯ RÃˆGLES DE VALIDATION ET QUALITÃ‰
export const VALIDATION_RULES: NotificationRule[] = [
  {
    id: 'mission_validation_required',
    name: 'Validation Mission Requise',
    description: 'Demande validation quand mission complÃ¨te',
    enabled: true,
    trigger: {
      event: 'mission_completed',
      conditions: {
        all_workshops_completed: { operator: 'equals', value: true },
        validation_status: { operator: 'equals', value: 'pending' }
      }
    },
    template: ALL_TEMPLATES.MISSION_VALIDATION_REQUIRED,
    cooldown: 3600000, // 1h entre demandes
    maxPerDay: 3,
    targetUsers: []
  },

  {
    id: 'ai_inconsistency_detection',
    name: 'DÃ©tection IA d\'IncohÃ©rences',
    description: 'Alerte quand l\'IA dÃ©tecte des incohÃ©rences',
    enabled: true,
    trigger: {
      event: 'ai_analysis_completed',
      conditions: {
        inconsistencies_found: { operator: 'greater_than', value: 0 },
        confidence_level: { operator: 'greater_than', value: 0.8 }
      }
    },
    template: ALL_TEMPLATES.DATA_INCONSISTENCY_DETECTED,
    cooldown: 1800000, // 30min entre alertes similaires
    maxPerDay: 10,
    targetUsers: []
  },

  {
    id: 'compliance_check_failure',
    name: 'Ã‰chec VÃ©rification ConformitÃ©',
    description: 'Alerte urgente pour non-conformitÃ© ANSSI',
    enabled: true,
    trigger: {
      event: 'compliance_check_completed',
      conditions: {
        compliance_status: { operator: 'equals', value: 'failed' },
        standard: { operator: 'contains', value: 'ANSSI' }
      }
    },
    template: ALL_TEMPLATES.COMPLIANCE_CHECK_FAILED,
    cooldown: 0, // Pas de cooldown pour conformitÃ©
    maxPerDay: 50,
    targetUsers: []
  }
];

// ðŸŽ¯ RÃˆGLES DE RAPPORTS
export const REPORT_RULES: NotificationRule[] = [
  {
    id: 'report_generation_success',
    name: 'Rapport GÃ©nÃ©rÃ© avec SuccÃ¨s',
    description: 'Notification quand rapport prÃªt au tÃ©lÃ©chargement',
    enabled: true,
    trigger: {
      event: 'report_generated',
      conditions: {
        status: { operator: 'equals', value: 'success' },
        file_size: { operator: 'greater_than', value: 0 }
      }
    },
    template: ALL_TEMPLATES.REPORT_GENERATED,
    cooldown: 0,
    maxPerDay: 20,
    targetUsers: []
  },

  {
    id: 'report_generation_failure',
    name: 'Ã‰chec GÃ©nÃ©ration Rapport',
    description: 'Alerte en cas d\'Ã©chec de gÃ©nÃ©ration',
    enabled: true,
    trigger: {
      event: 'report_generation_failed',
      conditions: {
        retry_count: { operator: 'less_than', value: 3 }
      }
    },
    template: ALL_TEMPLATES.REPORT_GENERATION_ERROR,
    cooldown: 600000, // 10min entre tentatives
    maxPerDay: 10,
    targetUsers: []
  },

  {
    id: 'report_shared_notification',
    name: 'Rapport PartagÃ©',
    description: 'Notification quand rapport partagÃ© avec utilisateur',
    enabled: true,
    trigger: {
      event: 'report_shared',
      conditions: {
        target_user_id: { operator: 'exists', value: true }
      }
    },
    template: ALL_TEMPLATES.REPORT_SHARED,
    cooldown: 0,
    maxPerDay: 30,
    targetUsers: []
  }
];

// ðŸŽ¯ RÃˆGLES DE COLLABORATION
export const COLLABORATION_RULES: NotificationRule[] = [
  {
    id: 'new_comment_notification',
    name: 'Nouveau Commentaire',
    description: 'Notification pour nouveaux commentaires',
    enabled: true,
    trigger: {
      event: 'comment_added',
      conditions: {
        target_user_id: { operator: 'exists', value: true },
        comment_length: { operator: 'greater_than', value: 10 }
      }
    },
    template: ALL_TEMPLATES.NEW_COMMENT,
    cooldown: 300000, // 5min entre commentaires
    maxPerDay: 50,
    targetUsers: []
  },

  {
    id: 'team_invitation_notification',
    name: 'Invitation Ã‰quipe',
    description: 'Notification d\'invitation Ã  rejoindre une Ã©quipe',
    enabled: true,
    trigger: {
      event: 'team_invitation_sent',
      conditions: {
        invitee_user_id: { operator: 'exists', value: true }
      }
    },
    template: ALL_TEMPLATES.TEAM_INVITATION,
    cooldown: 0,
    maxPerDay: 10,
    targetUsers: []
  },

  {
    id: 'review_request_notification',
    name: 'Demande de RÃ©vision',
    description: 'Notification de demande d\'avis expert',
    enabled: true,
    trigger: {
      event: 'review_requested',
      conditions: {
        reviewer_user_id: { operator: 'exists', value: true },
        urgency_level: { operator: 'in', value: ['medium', 'high', 'urgent'] }
      }
    },
    template: ALL_TEMPLATES.REVIEW_REQUEST,
    cooldown: 1800000, // 30min entre demandes
    maxPerDay: 15,
    targetUsers: []
  }
];

// ðŸŽ¯ RÃˆGLES DE SYNCHRONISATION
export const SYNC_RULES: NotificationRule[] = [
  {
    id: 'sync_success_summary',
    name: 'RÃ©sumÃ© Sync RÃ©ussie',
    description: 'Notification de succÃ¨s avec rÃ©sumÃ©',
    enabled: true,
    trigger: {
      event: 'sync_completed',
      conditions: {
        status: { operator: 'equals', value: 'success' },
        items_synced: { operator: 'greater_than', value: 5 }
      }
    },
    template: ALL_TEMPLATES.SYNC_SUCCESS,
    cooldown: 3600000, // 1h entre rÃ©sumÃ©s
    maxPerDay: 5,
    targetUsers: []
  },

  {
    id: 'sync_failure_alert',
    name: 'Alerte Ã‰chec Sync',
    description: 'Alerte en cas d\'Ã©chec de synchronisation',
    enabled: true,
    trigger: {
      event: 'sync_failed',
      conditions: {
        consecutive_failures: { operator: 'greater_than', value: 2 }
      }
    },
    template: ALL_TEMPLATES.SYNC_FAILED,
    cooldown: 1800000, // 30min entre alertes
    maxPerDay: 10,
    targetUsers: []
  },

  {
    id: 'sync_conflict_resolution',
    name: 'RÃ©solution Conflit Sync',
    description: 'Notification de conflit nÃ©cessitant intervention',
    enabled: true,
    trigger: {
      event: 'sync_conflict_detected',
      conditions: {
        auto_resolution_failed: { operator: 'equals', value: true }
      }
    },
    template: ALL_TEMPLATES.SYNC_CONFLICT,
    cooldown: 0, // Pas de cooldown pour conflits
    maxPerDay: 20,
    targetUsers: []
  }
];

// ðŸŽ¯ RÃˆGLES CONTEXTUELLES AVANCÃ‰ES
export const CONTEXTUAL_RULES: NotificationRule[] = [
  {
    id: 'weekend_reminder',
    name: 'Rappel Weekend',
    description: 'Rappel doux pour continuer la formation le weekend',
    enabled: true,
    trigger: {
      event: 'time_based_check',
      conditions: {
        day_of_week: { operator: 'in', value: ['saturday', 'sunday'] },
        user_active_weekends: { operator: 'equals', value: true },
        last_activity_days: { operator: 'greater_than', value: 2 }
      }
    },
    template: ALL_TEMPLATES.INACTIVITY_REMINDER,
    cooldown: 172800000, // 48h entre rappels weekend
    maxPerDay: 1,
    targetUsers: []
  },

  {
    id: 'deadline_approaching',
    name: 'Ã‰chÃ©ance Approche',
    description: 'Alerte quand Ã©chÃ©ance de mission approche',
    enabled: true,
    trigger: {
      event: 'deadline_check',
      conditions: {
        days_until_deadline: { operator: 'in_range', value: [1, 7] },
        mission_completion: { operator: 'less_than', value: 80 }
      }
    },
    template: ALL_TEMPLATES.MISSION_VALIDATION_REQUIRED,
    cooldown: 86400000, // 24h entre rappels d'Ã©chÃ©ance
    maxPerDay: 2,
    targetUsers: []
  },

  {
    id: 'expert_recommendation',
    name: 'Recommandation Expert',
    description: 'Suggestion de contenu basÃ©e sur le niveau',
    enabled: true,
    trigger: {
      event: 'user_level_updated',
      conditions: {
        new_level: { operator: 'in', value: ['intermediate', 'advanced', 'expert'] },
        completion_rate: { operator: 'greater_than', value: 75 }
      }
    },
    template: ALL_TEMPLATES.NEW_MODULE_AVAILABLE,
    cooldown: 604800000, // 7 jours entre recommandations
    maxPerDay: 1,
    targetUsers: []
  }
];

// ðŸŽ¯ EXPORT GLOBAL DES RÃˆGLES
export const ALL_NOTIFICATION_RULES = [
  ...FORMATION_RULES,
  ...VALIDATION_RULES,
  ...REPORT_RULES,
  ...COLLABORATION_RULES,
  ...SYNC_RULES,
  ...CONTEXTUAL_RULES
];

// ðŸŽ¯ UTILITAIRES POUR LES RÃˆGLES
export class NotificationRuleUtils {
  
  // VÃ©rifier si une condition est remplie
  static checkCondition(condition: TriggerCondition, eventData: any): boolean {
    const fieldValue = this.getNestedValue(eventData, condition.field);
    
    if (fieldValue === undefined && !condition.optional) {
      return false;
    }
    
    switch (condition.operator) {
      case 'equals':
        return fieldValue === condition.value;
      case 'not_equals':
        return fieldValue !== condition.value;
      case 'greater_than':
        return Number(fieldValue) > Number(condition.value);
      case 'less_than':
        return Number(fieldValue) < Number(condition.value);
      case 'contains':
        return String(fieldValue).includes(String(condition.value));
      case 'exists':
        return fieldValue !== undefined && fieldValue !== null;
      case 'in':
        return Array.isArray(condition.value) && condition.value.includes(fieldValue);
      case 'in_range':
        const [min, max] = condition.value;
        const numValue = Number(fieldValue);
        return numValue >= min && numValue <= max;
      default:
        return false;
    }
  }
  
  // RÃ©cupÃ©rer une valeur imbriquÃ©e dans un objet
  static getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }
  
  // VÃ©rifier si toutes les conditions d'une rÃ¨gle sont remplies
  static checkRuleConditions(rule: NotificationRule, event: TriggerEvent): boolean {
    const conditions = rule.trigger.conditions;
    
    return Object.entries(conditions).every(([field, condition]) => {
      return this.checkCondition({ field, ...condition }, event.data);
    });
  }
  
  // Filtrer les rÃ¨gles applicables pour un Ã©vÃ©nement
  static getApplicableRules(event: TriggerEvent, rules: NotificationRule[] = ALL_NOTIFICATION_RULES): NotificationRule[] {
    return rules.filter(rule => {
      // VÃ©rifier si la rÃ¨gle est activÃ©e
      if (!rule.enabled) return false;
      
      // VÃ©rifier si l'Ã©vÃ©nement correspond
      if (rule.trigger.event !== event.type) return false;
      
      // VÃ©rifier les conditions
      return this.checkRuleConditions(rule, event);
    });
  }
  
  // Calculer la prioritÃ© d'une notification basÃ©e sur le contexte
  static calculatePriority(rule: NotificationRule, event: TriggerEvent): NotificationPriority {
    const basePriority = rule.template.priority;
    
    // Augmenter la prioritÃ© selon certains critÃ¨res
    if (event.data.urgency_level === 'urgent') return 'urgent';
    if (event.data.severity === 'critical') return 'urgent';
    if (event.data.compliance_issue === true) return 'urgent';
    
    // Diminuer la prioritÃ© pour certains cas
    if (event.data.user_preference_low_priority === true) return 'low';
    
    return basePriority;
  }
}

export default ALL_NOTIFICATION_RULES;
