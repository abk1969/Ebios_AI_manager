/**
 * üîó SERVICE D'INT√âGRATION FORMATION
 * Service pour faire le pont entre Redux et le module formation
 * Synchronisation bidirectionnelle des √©tats
 */

import { store } from '@/store';
import { 
  TrainingSession, 
  Learner, 
  trainingEventBus, 
  TrainingEventType,
  TrainingEventFactory,
  useTrainingStore
} from '@/modules/training';
import { 
  addSession, 
  updateSession, 
  addLearner, 
  updateLearner,
  setCurrentSession,
  updateSessionStatus
} from '@/store/slices/trainingSlice';

/**
 * üéØ SERVICE PRINCIPAL D'INT√âGRATION
 */
export class TrainingIntegrationService {
  private static instance: TrainingIntegrationService;
  private isInitialized = false;
  private isSyncing = false; // Protection contre les boucles de synchronisation
  private eventSubscriptions: string[] = [];

  private constructor() {}

  static getInstance(): TrainingIntegrationService {
    if (!TrainingIntegrationService.instance) {
      TrainingIntegrationService.instance = new TrainingIntegrationService();
    }
    return TrainingIntegrationService.instance;
  }

  /**
   * üöÄ Initialiser l'int√©gration - D√âSACTIV√â
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    // üö® SERVICE D√âSACTIV√â - Module formation ind√©pendant
    console.log('‚ö†Ô∏è Service d\'int√©gration formation d√©sactiv√© - Module ind√©pendant');
    this.isInitialized = true;
    return;

    /* ANCIEN CODE D√âSACTIV√â POUR √âVITER LES CONFLITS
    console.log('üîó Initialisation du service d\'int√©gration formation...');

    try {
      // üõ°Ô∏è V√âRIFICATION S√âCURIT√â: S'assurer que l'environnement est stable
      if (!this.checkEnvironmentSafety()) {
        console.warn('‚ö†Ô∏è Environnement non s√©curis√©, initialisation formation annul√©e');
        return;
      }
      // 1. Configurer les √©couteurs d'√©v√©nements
      this.setupEventListeners();

      // 2. Synchroniser les √©tats initiaux
      await this.syncInitialStates();

      // 3. Configurer la synchronisation bidirectionnelle (avec protection anti-boucle)
      this.setupBidirectionalSync();

      this.isInitialized = true;
      console.log('‚úÖ Service d\'int√©gration formation initialis√©');

    } catch (error) {
      console.error('‚ùå Erreur lors de l\'initialisation du service d\'int√©gration:', error);
      throw error;
    }
    */
  }

  /**
   * üéß Configurer les √©couteurs d'√©v√©nements du module formation
   */
  private setupEventListeners(): void {
    // √âcouter les √©v√©nements de session
    const sessionSubscription = trainingEventBus.subscribe(
      [
        TrainingEventType.SESSION_CREATED,
        TrainingEventType.SESSION_STARTED,
        TrainingEventType.SESSION_COMPLETED,
        TrainingEventType.STEP_COMPLETED
      ],
      {
        handle: (event) => this.handleSessionEvent(event),
        canHandle: () => true,
        priority: 1
      }
    );

    // √âcouter les √©v√©nements d'apprenant
    const learnerSubscription = trainingEventBus.subscribe(
      [
        TrainingEventType.LEARNER_REGISTERED,
        TrainingEventType.LEARNER_PROFILE_UPDATED,
        TrainingEventType.LEARNER_SKILLS_UPDATED
      ],
      {
        handle: (event) => this.handleLearnerEvent(event),
        canHandle: () => true,
        priority: 1
      }
    );

    // √âcouter les √©v√©nements d'√©valuation
    const assessmentSubscription = trainingEventBus.subscribe(
      [
        TrainingEventType.ASSESSMENT_COMPLETED,
        TrainingEventType.BADGE_EARNED,
        TrainingEventType.CERTIFICATION_AWARDED
      ],
      {
        handle: (event) => this.handleAssessmentEvent(event),
        canHandle: () => true,
        priority: 1
      }
    );

    this.eventSubscriptions.push(sessionSubscription, learnerSubscription, assessmentSubscription);
  }

  /**
   * üîÑ Synchroniser les √©tats initiaux
   */
  private async syncInitialStates(): Promise<void> {
    // R√©cup√©rer l'√©tat actuel du module formation
    const trainingState = useTrainingStore.getState();
    
    // Synchroniser avec Redux si n√©cessaire
    if (trainingState.currentSession) {
      store.dispatch(setCurrentSession(trainingState.currentSession.id.value));
    }

    if (trainingState.sessionStatus !== 'idle') {
      store.dispatch(updateSessionStatus(trainingState.sessionStatus));
    }
  }

  /**
   * üîÑ Configurer la synchronisation bidirectionnelle (AVEC PROTECTION ANTI-BOUCLE)
   */
  private setupBidirectionalSync(): void {
    // √âcouter les changements dans le store Redux
    store.subscribe(() => {
      if (this.isSyncing) return; // Protection contre les boucles

      const reduxState = store.getState().training;
      const trainingState = useTrainingStore.getState();

      // Synchroniser la session courante
      if (reduxState.currentSessionId !== trainingState.currentSession?.id.value) {
        this.isSyncing = true;
        this.syncCurrentSession(reduxState.currentSessionId);
        setTimeout(() => { this.isSyncing = false; }, 100); // Reset apr√®s d√©lai
      }
    });

    // √âcouter les changements dans le store Zustand
    useTrainingStore.subscribe(
      (state) => state.currentSession,
      (currentSession) => {
        if (this.isSyncing) return; // Protection contre les boucles

        const reduxState = store.getState().training;
        if (currentSession?.id.value !== reduxState.currentSessionId) {
          this.isSyncing = true;
          store.dispatch(setCurrentSession(currentSession?.id.value || null));
          setTimeout(() => { this.isSyncing = false; }, 100); // Reset apr√®s d√©lai
        }
      }
    );
  }

  /**
   * üéØ G√©rer les √©v√©nements de session
   */
  private async handleSessionEvent(event: any): Promise<void> {
    const { type, payload } = event;

    switch (type) {
      case TrainingEventType.SESSION_CREATED:
        await this.handleSessionCreated(payload);
        break;

      case TrainingEventType.SESSION_STARTED:
        store.dispatch(updateSessionStatus('active'));
        break;

      case TrainingEventType.SESSION_COMPLETED:
        store.dispatch(updateSessionStatus('completed'));
        await this.handleSessionCompleted(payload);
        break;

      case TrainingEventType.STEP_COMPLETED:
        await this.handleStepCompleted(payload);
        break;
    }
  }

  /**
   * üéØ G√©rer les √©v√©nements d'apprenant
   */
  private async handleLearnerEvent(event: any): Promise<void> {
    const { type, payload } = event;

    switch (type) {
      case TrainingEventType.LEARNER_REGISTERED:
        await this.handleLearnerRegistered(payload);
        break;

      case TrainingEventType.LEARNER_PROFILE_UPDATED:
      case TrainingEventType.LEARNER_SKILLS_UPDATED:
        await this.handleLearnerUpdated(payload);
        break;
    }
  }

  /**
   * üéØ G√©rer les √©v√©nements d'√©valuation
   */
  private async handleAssessmentEvent(event: any): Promise<void> {
    const { type, payload } = event;

    // Mettre √† jour les m√©triques globales
    const reduxState = store.getState().training;
    
    // Ici, on pourrait mettre √† jour des statistiques globales
    console.log(`√âv√©nement d'√©valuation: ${type}`, payload);
  }

  /**
   * üéØ Handlers sp√©cifiques
   */
  private async handleSessionCreated(payload: any): Promise<void> {
    // Ajouter la session au store Redux
    if (payload.session) {
      store.dispatch(addSession(payload.session));
      store.dispatch(setCurrentSession(payload.session.id.value));
    }
  }

  private async handleSessionCompleted(payload: any): Promise<void> {
    // Mettre √† jour les m√©triques de completion
    if (payload.sessionId) {
      store.dispatch(updateSession({
        id: payload.sessionId,
        updates: { status: 'completed' }
      }));
    }
  }

  private async handleStepCompleted(payload: any): Promise<void> {
    // Mettre √† jour la progression
    if (payload.sessionId && payload.stepId) {
      // Ici, on pourrait mettre √† jour la progression d√©taill√©e
      console.log(`√âtape ${payload.stepId} termin√©e pour la session ${payload.sessionId}`);
    }
  }

  private async handleLearnerRegistered(payload: any): Promise<void> {
    if (payload.learner) {
      store.dispatch(addLearner(payload.learner));
    }
  }

  private async handleLearnerUpdated(payload: any): Promise<void> {
    if (payload.learnerId && payload.updates) {
      store.dispatch(updateLearner({
        id: payload.learnerId,
        updates: payload.updates
      }));
    }
  }

  /**
   * üîÑ Synchroniser la session courante
   */
  private syncCurrentSession(sessionId: string | null): void {
    const trainingActions = useTrainingStore.getState();
    
    if (sessionId) {
      // Trouver la session dans le store Redux
      const reduxState = store.getState().training;
      const session = reduxState.sessions.find(s => s.id.value === sessionId);
      
      if (session) {
        // Mettre √† jour le store Zustand
        trainingActions.setCurrentSession(session);
      }
    } else {
      trainingActions.setCurrentSession(null);
    }
  }

  /**
   * üéØ API publique pour l'int√©gration
   */

  /**
   * Cr√©er une session depuis l'application principale - D√âSACTIV√â
   */
  async createSessionFromApp(config: {
    learnerId: string;
    workshopSequence: number[];
    sectorCustomization?: string;
  }): Promise<{ success: boolean; sessionId?: string; error?: string }> {
    // üö® SERVICE D√âSACTIV√â - Module formation ind√©pendant
    console.log('‚ö†Ô∏è createSessionFromApp d√©sactiv√© - Module ind√©pendant');

    return {
      success: true,
      sessionId: 'session_healthcare_chu_2024' // ID par d√©faut
    };

    /* ANCIEN CODE D√âSACTIV√â
    try {
      // √âmettre un √©v√©nement pour cr√©er la session
      const event = TrainingEventFactory.createSessionEvent(
        TrainingEventType.SESSION_CREATED,
        'temp_session_id',
        config.learnerId,
        config,
        { source: 'TrainingIntegrationService' }
      );

      await trainingEventBus.emit(event);

      return { success: true, sessionId: event.id };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erreur inconnue'
      };
    }
    */
  }

  /**
   * Obtenir les m√©triques de formation - D√âSACTIV√â
   */
  getTrainingMetrics() {
    // üö® SERVICE D√âSACTIV√â - Retourner des m√©triques par d√©faut
    console.log('‚ö†Ô∏è getTrainingMetrics d√©sactiv√© - Module ind√©pendant');

    return {
      redux: { totalSessions: 0, completedSessions: 0, averageCompletionRate: 0, totalLearners: 0 },
      module: { engagementScore: 50, comprehensionLevel: 50, responseQuality: 50 },
      combined: {
        totalSessions: 0,
        activeSessions: 0,
        completionRate: 0,
        engagement: 50
      }
    };

    /* ANCIEN CODE D√âSACTIV√â
    const reduxState = store.getState().training;
    const trainingState = useTrainingStore.getState();

    return {
      redux: reduxState.globalMetrics,
      module: trainingState.metrics,
      combined: {
        totalSessions: reduxState.globalMetrics.totalSessions,
        activeSessions: reduxState.sessions.filter(s => s.isActive).length,
        completionRate: reduxState.globalMetrics.averageCompletionRate,
        engagement: trainingState.metrics.engagementScore
      }
    };
    */
  }

  /**
   * üõ°Ô∏è V√©rification s√©curit√© environnement
   */
  private checkEnvironmentSafety(): boolean {
    try {
      // V√©rifier que les d√©pendances critiques sont disponibles
      if (typeof window === 'undefined') return false;
      if (!window.localStorage) return false;
      if (!store) return false;

      // V√©rifier que Redux fonctionne
      const state = store.getState();
      if (!state) return false;

      return true;
    } catch (error) {
      console.error('üö® Erreur v√©rification s√©curit√©:', error);
      return false;
    }
  }

  /**
   * üßπ Nettoyage
   */
  cleanup(): void {
    // D√©sabonner tous les √©v√©nements
    this.eventSubscriptions.forEach(subscriptionId => {
      trainingEventBus.unsubscribe(subscriptionId);
    });
    
    this.eventSubscriptions = [];
    this.isInitialized = false;
  }
}

// üéØ Instance globale
export const trainingIntegrationService = TrainingIntegrationService.getInstance();
