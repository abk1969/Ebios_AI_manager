/**
 * üìä MONITORING AGENT - SURVEILLANCE ET M√âTRIQUES SYST√àME
 * Agent sp√©cialis√© pour la surveillance des performances et de la sant√© du syst√®me
 * Collecte et analyse les m√©triques de tous les agents EBIOS RM
 */

import { 
  EBIOSAgent, 
  AgentConfig, 
  AgentTask, 
  AgentResult, 
  AgentStatus, 
  AgentMetrics,
  AgentCapability
} from '../AgentInterface';
import { Logger } from '../../logging/Logger';
import { MetricsCollector } from '../../monitoring/MetricsCollector';
import { CircuitBreaker, CircuitBreakerState } from '../../resilience/CircuitBreaker'; // üîß CORRECTION: Import de l'enum

export interface SystemHealth {
  overall: 'healthy' | 'degraded' | 'critical' | 'unknown';
  score: number; // 0-100
  components: {
    agents: ComponentHealth;
    infrastructure: ComponentHealth;
    performance: ComponentHealth;
    security: ComponentHealth;
  };
  alerts: Alert[];
  recommendations: string[];
  lastUpdated: Date;
}

export interface ComponentHealth {
  status: 'healthy' | 'warning' | 'critical' | 'unknown';
  score: number; // 0-100
  metrics: Record<string, number>;
  issues: Issue[];
  trends: Trend[];
}

export interface Alert {
  id: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  title: string;
  description: string;
  source: string;
  timestamp: Date;
  acknowledged: boolean;
  resolvedAt?: Date;
  metadata: Record<string, any>;
}

export interface Issue {
  id: string;
  type: 'performance' | 'availability' | 'error' | 'security' | 'compliance';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  impact: string;
  recommendation: string;
  firstSeen: Date;
  lastSeen: Date;
  occurrences: number;
}

export interface Trend {
  metric: string;
  direction: 'improving' | 'stable' | 'degrading';
  change: number; // Pourcentage de changement
  period: string;
  significance: 'low' | 'medium' | 'high';
}

export interface PerformanceReport {
  period: {
    start: Date;
    end: Date;
  };
  summary: {
    totalRequests: number;
    successRate: number;
    averageResponseTime: number;
    errorRate: number;
    availabilityPercentage: number;
  };
  agentMetrics: Record<string, AgentPerformanceMetrics>;
  systemMetrics: SystemMetrics;
  trends: Trend[];
  insights: string[];
  recommendations: string[];
}

export interface AgentPerformanceMetrics {
  agentId: string;
  agentType: string;
  executionCount: number;
  successRate: number;
  averageExecutionTime: number;
  errorCount: number;
  lastActivity: Date;
  resourceUsage: {
    cpu: number;
    memory: number;
    network: number;
  };
  customMetrics: Record<string, any>;
}

export interface SystemMetrics {
  cpu: {
    usage: number;
    load: number[];
  };
  memory: {
    used: number;
    total: number;
    percentage: number;
  };
  disk: {
    used: number;
    total: number;
    percentage: number;
  };
  network: {
    bytesIn: number;
    bytesOut: number;
    connectionsActive: number;
  };
  application: {
    uptime: number;
    version: string;
    environment: string;
  };
}

export interface MonitoringConfig {
  healthCheckInterval: number; // ms
  metricsCollectionInterval: number; // ms
  alertThresholds: {
    responseTime: number; // ms
    errorRate: number; // percentage
    cpuUsage: number; // percentage
    memoryUsage: number; // percentage
    diskUsage: number; // percentage
  };
  retentionPeriod: number; // days
  enableRealTimeAlerts: boolean;
  enableTrendAnalysis: boolean;
}

/**
 * Agent sp√©cialis√© dans la surveillance et le monitoring du syst√®me EBIOS RM
 * Collecte les m√©triques, d√©tecte les anomalies et g√©n√®re des alertes
 */
export class MonitoringAgent implements EBIOSAgent {
  public readonly agentId: string;
  public readonly capabilities: AgentCapability[] = [AgentCapability.WORKFLOW_ORCHESTRATION]; // üîß CORRECTION: Capability existante pour monitoring

  // üîß CORRECTION: Propri√©t√©s manquantes pour EBIOSAgent
  public get metrics(): AgentMetrics {
    return this.getMetrics();
  }

  public canHandle(taskType: string): boolean {
    const supportedTypes = ['health_check', 'collect_metrics', 'generate_report', 'analyze_trends', 'detect_anomalies', 'get_system_status', 'get_alerts'];
    return supportedTypes.includes(taskType);
  }

  public async heartbeat(): Promise<void> {
    // Pas de retour pour void
  }
  
  public status: AgentStatus = AgentStatus.IDLE; // üîß CORRECTION: Propri√©t√© publique
  private config: AgentConfig;
  private monitoringConfig: MonitoringConfig;
  private logger: Logger;
  private metricsCollector: MetricsCollector;
  private circuitBreaker: CircuitBreaker;
  
  // √âtat du monitoring
  private currentHealth: SystemHealth;
  private alerts: Map<string, Alert> = new Map();
  private issues: Map<string, Issue> = new Map();
  private metricsHistory: Map<string, any[]> = new Map();
  
  // Timers pour les t√¢ches p√©riodiques
  private healthCheckTimer?: NodeJS.Timeout;
  private metricsCollectionTimer?: NodeJS.Timeout;
  private cleanupTimer?: NodeJS.Timeout;
  
  // Seuils et r√®gles de surveillance
  private readonly defaultThresholds = {
    responseTime: 5000, // 5 secondes
    errorRate: 5, // 5%
    cpuUsage: 80, // 80%
    memoryUsage: 85, // 85%
    diskUsage: 90, // 90%
    agentSuccessRate: 95, // 95%
    systemAvailability: 99.5 // 99.5%
  };
  
  // R√®gles de d√©tection d'anomalies
  private readonly anomalyRules = {
    responseTimeSpike: (current: number, baseline: number) => current > baseline * 2,
    errorRateIncrease: (current: number, baseline: number) => current > baseline + 10,
    memoryLeak: (trend: Trend) => trend.direction === 'degrading' && trend.change > 20,
    performanceDegradation: (trend: Trend) => trend.direction === 'degrading' && trend.significance === 'high'
  };

  constructor(config: AgentConfig, monitoringConfig?: Partial<MonitoringConfig>) {
    this.agentId = config.agentId;
    this.config = config;
    this.monitoringConfig = {
      healthCheckInterval: 30000, // 30 secondes
      metricsCollectionInterval: 60000, // 1 minute
      alertThresholds: this.defaultThresholds,
      retentionPeriod: 30, // 30 jours
      enableRealTimeAlerts: true,
      enableTrendAnalysis: true,
      ...monitoringConfig
    };
    
    this.logger = new Logger('MonitoringAgent', { agentId: this.agentId });
    this.metricsCollector = MetricsCollector.getInstance();
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      recoveryTimeout: 60000,
      timeout: 10000
    });
    
    // Initialisation de l'√©tat de sant√©
    this.currentHealth = this.initializeHealthState();
  }

  public async initialize(): Promise<void> {
    this.logger.info('Initializing MonitoringAgent');
    this.status = AgentStatus.INITIALIZING;
    
    try {
      // Validation de la configuration
      await this.validateConfiguration();
      
      // Initialisation des m√©triques syst√®me
      await this.initializeSystemMetrics();
      
      // D√©marrage des t√¢ches p√©riodiques
      await this.startPeriodicTasks();
      
      // Test initial de sant√©
      await this.performInitialHealthCheck();
      
      this.status = AgentStatus.READY;
      this.logger.info('MonitoringAgent initialized successfully');
      
    } catch (error) {
      this.status = AgentStatus.ERROR;
      this.logger.error('Failed to initialize MonitoringAgent:', error);
      throw error;
    }
  }

  public async execute(task: AgentTask): Promise<AgentResult> {
    this.logger.info(`Executing monitoring task: ${task.type}`);
    this.status = AgentStatus.RUNNING;
    
    const startTime = Date.now();
    
    try {
      const result = await this.circuitBreaker.execute(
        () => this.executeMonitoringTask(task),
        () => this.executeFallback(task)
      );
      
      const executionTime = Date.now() - startTime;
      this.status = AgentStatus.READY;
      
      // Enregistrement des m√©triques
      this.metricsCollector.recordExecution({
        agentId: this.agentId,
        taskType: task.type,
        executionTime,
        success: true,
        metadata: { 
          taskId: task.id,
          dataSize: this.calculateDataSize(result),
          alertsGenerated: this.countAlertsGenerated(result)
        }
      });
      
      return {
        taskId: task.id,
        type: task.type, // üîß CORRECTION: Propri√©t√© type ajout√©e
        agentId: this.agentId,
        success: true,
        data: result,
        executionTime,
        metadata: {
          processingTime: Date.now() - startTime, // üîß CORRECTION: Propri√©t√© requise
          agentVersion: '1.0.0', // üîß CORRECTION: Propri√©t√© requise
          fallbackUsed: false
        }
      };
      
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.status = AgentStatus.ERROR;
      
      this.logger.error('Monitoring task failed:', error);
      
      // G√©n√©ration d'une alerte pour l'√©chec du monitoring
      await this.generateAlert({
        severity: 'error',
        title: 'Monitoring Task Failed',
        description: `Task ${task.type} failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        source: this.agentId,
        metadata: { taskId: task.id, taskType: task.type }
      });
      
      this.metricsCollector.recordExecution({
        agentId: this.agentId,
        taskType: task.type,
        executionTime,
        success: false,
        metadata: { 
          taskId: task.id, 
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      });
      
      return {
        taskId: task.id,
        type: task.type, // üîß CORRECTION: Propri√©t√© type ajout√©e
        agentId: this.agentId,
        success: false,
        data: null,
        error: error instanceof Error ? error.message : 'Unknown error',
        executionTime,
        metadata: {
          processingTime: Date.now() - Date.now(), // üîß CORRECTION: Propri√©t√© requise
          agentVersion: '1.0.0', // üîß CORRECTION: Propri√©t√© requise
          fallbackUsed: true
        }
      };
    }
  }

  public getStatus(): AgentStatus {
    return this.status;
  }

  public getMetrics(): AgentMetrics { // üîß CORRECTION: M√©thode synchrone
    const executions = this.metricsCollector.getExecutionRecords(this.agentId);
    
    const successfulExecutions = executions.filter(e => e.success).length;
    const totalExecutions = executions.length;
    
    const totalFailures = totalExecutions - successfulExecutions;

    return {
      tasksCompleted: totalExecutions, // üîß CORRECTION: Propri√©t√© correcte
      tasksFailures: totalFailures, // üîß CORRECTION: Propri√©t√© ajout√©e
      errorRate: totalExecutions > 0 ? (totalFailures / totalExecutions) * 100 : 0, // üîß CORRECTION: Propri√©t√© ajout√©e
      averageExecutionTime: totalExecutions > 0
        ? executions.reduce((sum, e) => sum + e.executionTime, 0) / totalExecutions
        : 0,
      lastHeartbeat: executions.length > 0
        ? executions[executions.length - 1].timestamp
        : new Date(), // üîß CORRECTION: Propri√©t√© correcte
      uptime: Date.now() - Date.now() // üîß CORRECTION: Propri√©t√© ajout√©e (placeholder)
    };
  }

  public async shutdown(): Promise<void> {
    this.logger.info('Shutting down MonitoringAgent');
    this.status = AgentStatus.SHUTDOWN;
    
    // Arr√™t des t√¢ches p√©riodiques
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
    }
    if (this.metricsCollectionTimer) {
      clearInterval(this.metricsCollectionTimer);
    }
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    
    // Sauvegarde finale des m√©triques
    await this.saveMetricsSnapshot();
    
    // Nettoyage des donn√©es en m√©moire
    this.alerts.clear();
    this.issues.clear();
    this.metricsHistory.clear();
  }

  // M√©thodes publiques pour l'acc√®s aux donn√©es de monitoring
  
  public getCurrentHealth(): SystemHealth {
    return { ...this.currentHealth };
  }

  public getActiveAlerts(): Alert[] {
    return Array.from(this.alerts.values()).filter(alert => !alert.acknowledged);
  }

  public getActiveIssues(): Issue[] {
    return Array.from(this.issues.values());
  }

  public async generatePerformanceReport(period: { start: Date; end: Date }): Promise<PerformanceReport> {
    this.logger.info(`Generating performance report for period ${period.start.toISOString()} to ${period.end.toISOString()}`);
    
    const allExecutions = this.metricsCollector.getExecutionRecords() // üîß CORRECTION: M√©thode correcte
      .filter(e => e.timestamp >= period.start && e.timestamp <= period.end);
    
    const summary = this.calculateSummaryMetrics(allExecutions);
    const agentMetrics = this.calculateAgentMetrics(allExecutions);
    const systemMetrics = await this.getSystemMetrics();
    const trends = this.calculateTrends(period);
    const insights = this.generateInsights(summary, trends);
    const recommendations = this.generateRecommendations(summary, trends, agentMetrics);
    
    return {
      period,
      summary,
      agentMetrics,
      systemMetrics,
      trends,
      insights,
      recommendations
    };
  }

  public async acknowledgeAlert(alertId: string): Promise<void> {
    const alert = this.alerts.get(alertId);
    if (alert) {
      alert.acknowledged = true;
      this.logger.info(`Alert ${alertId} acknowledged`);
    }
  }

  public async resolveAlert(alertId: string): Promise<void> {
    const alert = this.alerts.get(alertId);
    if (alert) {
      alert.resolvedAt = new Date();
      this.alerts.delete(alertId);
      this.logger.info(`Alert ${alertId} resolved`);
    }
  }

  // M√©thodes priv√©es pour l'ex√©cution des t√¢ches
  
  private async executeMonitoringTask(task: AgentTask): Promise<any> {
    switch (task.type) {
      case 'health_check':
        return await this.performHealthCheck();
      
      case 'collect_metrics':
        return await this.collectMetrics();
      
      case 'generate_report':
        return await this.generatePerformanceReport(task.data.period);
      
      case 'analyze_trends':
        return await this.analyzeTrends(task.data.period);
      
      case 'detect_anomalies':
        return await this.detectAnomalies();
      
      case 'get_system_status':
        return this.getSystemStatus();
      
      case 'get_alerts':
        return this.getAlertsData(task.data.filters);
      
      default:
        throw new Error(`Unknown monitoring task type: ${task.type}`);
    }
  }

  private async performHealthCheck(): Promise<SystemHealth> {
    this.logger.debug('Performing system health check');
    
    // V√©rification de la sant√© des agents
    const agentsHealth = await this.checkAgentsHealth();
    
    // V√©rification de l'infrastructure
    const infrastructureHealth = await this.checkInfrastructureHealth();
    
    // V√©rification des performances
    const performanceHealth = await this.checkPerformanceHealth();
    
    // V√©rification de la s√©curit√©
    const securityHealth = await this.checkSecurityHealth();
    
    // Calcul du score global
    const overallScore = this.calculateOverallHealthScore({
      agents: agentsHealth,
      infrastructure: infrastructureHealth,
      performance: performanceHealth,
      security: securityHealth
    });
    
    // G√©n√©ration des alertes si n√©cessaire
    await this.checkForAlerts({
      agents: agentsHealth,
      infrastructure: infrastructureHealth,
      performance: performanceHealth,
      security: securityHealth
    });
    
    // Mise √† jour de l'√©tat de sant√©
    this.currentHealth = {
      overall: this.getOverallStatus(overallScore),
      score: overallScore,
      components: {
        agents: agentsHealth,
        infrastructure: infrastructureHealth,
        performance: performanceHealth,
        security: securityHealth
      },
      alerts: this.getActiveAlerts(),
      recommendations: this.generateHealthRecommendations(overallScore),
      lastUpdated: new Date()
    };
    
    return this.currentHealth;
  }

  private async collectMetrics(): Promise<any> {
    this.logger.debug('Collecting system metrics');
    
    const systemMetrics = await this.getSystemMetrics();
    const agentMetrics = await this.getAllAgentMetrics();
    const applicationMetrics = this.getApplicationMetrics();
    
    // Stockage des m√©triques dans l'historique
    const timestamp = new Date().toISOString();
    this.storeMetricsInHistory('system', systemMetrics, timestamp);
    this.storeMetricsInHistory('agents', agentMetrics, timestamp);
    this.storeMetricsInHistory('application', applicationMetrics, timestamp);
    
    // Nettoyage des anciennes m√©triques
    await this.cleanupOldMetrics();
    
    return {
      timestamp,
      system: systemMetrics,
      agents: agentMetrics,
      application: applicationMetrics
    };
  }

  private async analyzeTrends(period: { start: Date; end: Date }): Promise<Trend[]> {
    this.logger.debug('Analyzing trends');
    
    const trends: Trend[] = [];
    
    // Analyse des tendances de performance
    const performanceTrends = this.analyzePerformanceTrends(period);
    trends.push(...performanceTrends);
    
    // Analyse des tendances d'utilisation des ressources
    const resourceTrends = this.analyzeResourceTrends(period);
    trends.push(...resourceTrends);
    
    // Analyse des tendances d'erreurs
    const errorTrends = this.analyzeErrorTrends(period);
    trends.push(...errorTrends);
    
    return trends;
  }

  private async detectAnomalies(): Promise<any> {
    this.logger.debug('Detecting anomalies');
    
    const anomalies: any[] = [];
    
    // D√©tection d'anomalies de performance
    const performanceAnomalies = await this.detectPerformanceAnomalies();
    anomalies.push(...performanceAnomalies);
    
    // D√©tection d'anomalies de ressources
    const resourceAnomalies = await this.detectResourceAnomalies();
    anomalies.push(...resourceAnomalies);
    
    // D√©tection d'anomalies d'erreurs
    const errorAnomalies = await this.detectErrorAnomalies();
    anomalies.push(...errorAnomalies);
    
    // G√©n√©ration d'alertes pour les anomalies critiques
    for (const anomaly of anomalies) {
      if (anomaly.severity === 'critical') {
        await this.generateAlert({
          severity: 'critical',
          title: `Anomalie d√©tect√©e: ${anomaly.type}`,
          description: anomaly.description,
          source: 'anomaly_detection',
          metadata: anomaly
        });
      }
    }
    
    return {
      anomalies,
      summary: {
        total: anomalies.length,
        critical: anomalies.filter(a => a.severity === 'critical').length,
        warning: anomalies.filter(a => a.severity === 'warning').length
      }
    };
  }

  private getSystemStatus(): any {
    return {
      health: this.currentHealth,
      uptime: process.uptime(),
      version: process.version,
      environment: process.env.NODE_ENV || 'development',
      timestamp: new Date()
    };
  }

  private getAlertsData(filters?: any): any {
    let alerts = Array.from(this.alerts.values());
    
    if (filters) {
      if (filters.severity) {
        alerts = alerts.filter(a => a.severity === filters.severity);
      }
      if (filters.acknowledged !== undefined) {
        alerts = alerts.filter(a => a.acknowledged === filters.acknowledged);
      }
      if (filters.source) {
        alerts = alerts.filter(a => a.source === filters.source);
      }
    }
    
    return {
      alerts,
      summary: {
        total: alerts.length,
        unacknowledged: alerts.filter(a => !a.acknowledged).length,
        bySeverity: this.groupAlertsBySeverity(alerts)
      }
    };
  }

  private async executeFallback(task: AgentTask): Promise<any> {
    this.logger.warn('Using fallback for monitoring task');
    
    return {
      status: 'fallback',
      message: 'Service de monitoring temporairement indisponible',
      timestamp: new Date(),
      fallbackData: {
        basicHealth: 'unknown',
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage()
      }
    };
  }

  // M√©thodes de v√©rification de sant√©
  
  private async checkAgentsHealth(): Promise<ComponentHealth> {
    const allAgents = await this.getAllRegisteredAgents();
    const healthyAgents = allAgents.filter(agent => agent.status === 'ready' || agent.status === 'running');
    
    const score = allAgents.length > 0 ? (healthyAgents.length / allAgents.length) * 100 : 100;
    const status = this.getComponentStatus(score);
    
    const issues: Issue[] = [];
    const unhealthyAgents = allAgents.filter(agent => agent.status === 'error' || agent.status === 'shutdown');
    
    for (const agent of unhealthyAgents) {
      issues.push({
        id: `agent_unhealthy_${agent.agentId}`,
        type: 'availability',
        severity: 'high',
        description: `Agent ${agent.agentId} is in ${agent.status} state`,
        impact: 'Reduced system functionality',
        recommendation: 'Restart or investigate agent issues',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    return {
      status,
      score,
      metrics: {
        totalAgents: allAgents.length,
        healthyAgents: healthyAgents.length,
        unhealthyAgents: unhealthyAgents.length,
        averageSuccessRate: this.calculateAverageAgentSuccessRate(allAgents)
      },
      issues,
      trends: []
    };
  }

  private async checkInfrastructureHealth(): Promise<ComponentHealth> {
    const systemMetrics = await this.getSystemMetrics();
    
    const cpuScore = Math.max(0, 100 - systemMetrics.cpu.usage);
    const memoryScore = Math.max(0, 100 - systemMetrics.memory.percentage);
    const diskScore = Math.max(0, 100 - systemMetrics.disk.percentage);
    
    const score = (cpuScore + memoryScore + diskScore) / 3;
    const status = this.getComponentStatus(score);
    
    const issues: Issue[] = [];
    
    if (systemMetrics.cpu.usage > this.monitoringConfig.alertThresholds.cpuUsage) {
      issues.push({
        id: 'high_cpu_usage',
        type: 'performance',
        severity: 'medium', // üîß CORRECTION: 'warning' ‚Üí 'medium'
        description: `CPU usage is ${systemMetrics.cpu.usage}%`,
        impact: 'Potential performance degradation',
        recommendation: 'Monitor CPU usage and consider scaling',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    if (systemMetrics.memory.percentage > this.monitoringConfig.alertThresholds.memoryUsage) {
      issues.push({
        id: 'high_memory_usage',
        type: 'performance',
        severity: 'medium', // üîß CORRECTION: 'warning' ‚Üí 'medium'
        description: `Memory usage is ${systemMetrics.memory.percentage}%`,
        impact: 'Risk of out-of-memory errors',
        recommendation: 'Monitor memory usage and consider optimization',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    return {
      status,
      score,
      metrics: {
        cpuUsage: systemMetrics.cpu.usage,
        memoryUsage: systemMetrics.memory.percentage,
        diskUsage: systemMetrics.disk.percentage,
        networkConnections: systemMetrics.network.connectionsActive
      },
      issues,
      trends: []
    };
  }

  private async checkPerformanceHealth(): Promise<ComponentHealth> {
    const recentExecutions = this.metricsCollector.getExecutionRecords() // üîß CORRECTION: M√©thode correcte
      .filter(e => e.timestamp > new Date(Date.now() - 5 * 60 * 1000)); // 5 derni√®res minutes
    
    if (recentExecutions.length === 0) {
      return {
        status: 'unknown',
        score: 50,
        metrics: {},
        issues: [],
        trends: []
      };
    }
    
    const successRate = (recentExecutions.filter(e => e.success).length / recentExecutions.length) * 100;
    const avgResponseTime = recentExecutions.reduce((sum, e) => sum + e.executionTime, 0) / recentExecutions.length;
    
    const successScore = successRate;
    const responseTimeScore = Math.max(0, 100 - (avgResponseTime / this.monitoringConfig.alertThresholds.responseTime) * 100);
    
    const score = (successScore + responseTimeScore) / 2;
    const status = this.getComponentStatus(score);
    
    const issues: Issue[] = [];
    
    if (successRate < this.defaultThresholds.agentSuccessRate) {
      issues.push({
        id: 'low_success_rate',
        type: 'performance',
        severity: 'high',
        description: `Success rate is ${successRate.toFixed(1)}%`,
        impact: 'Reduced system reliability',
        recommendation: 'Investigate failing operations',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    if (avgResponseTime > this.monitoringConfig.alertThresholds.responseTime) {
      issues.push({
        id: 'high_response_time',
        type: 'performance',
        severity: 'medium', // üîß CORRECTION: 'warning' ‚Üí 'medium'
        description: `Average response time is ${avgResponseTime.toFixed(0)}ms`,
        impact: 'Slower user experience',
        recommendation: 'Optimize performance or scale resources',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    return {
      status,
      score,
      metrics: {
        successRate,
        averageResponseTime: avgResponseTime,
        totalRequests: recentExecutions.length,
        errorCount: recentExecutions.filter(e => !e.success).length
      },
      issues,
      trends: []
    };
  }

  private async checkSecurityHealth(): Promise<ComponentHealth> {
    // V√©rifications de s√©curit√© basiques
    const securityChecks = {
      circuitBreakersActive: this.areCircuitBreakersHealthy(),
      loggingEnabled: this.isLoggingEnabled(),
      metricsSecure: this.areMetricsSecure(),
      alertsConfigured: this.areAlertsConfigured()
    };
    
    const passedChecks = Object.values(securityChecks).filter(Boolean).length;
    const totalChecks = Object.keys(securityChecks).length;
    
    const score = (passedChecks / totalChecks) * 100;
    const status = this.getComponentStatus(score);
    
    const issues: Issue[] = [];
    
    if (!securityChecks.circuitBreakersActive) {
      issues.push({
        id: 'circuit_breakers_inactive',
        type: 'security',
        severity: 'medium',
        description: 'Some circuit breakers are not active',
        impact: 'Reduced resilience to failures',
        recommendation: 'Verify circuit breaker configuration',
        firstSeen: new Date(),
        lastSeen: new Date(),
        occurrences: 1
      });
    }
    
    return {
      status,
      score,
      metrics: {
        securityChecksTotal: totalChecks,
        securityChecksPassed: passedChecks,
        circuitBreakersActive: securityChecks.circuitBreakersActive ? 1 : 0,
        loggingEnabled: securityChecks.loggingEnabled ? 1 : 0
      },
      issues,
      trends: []
    };
  }

  // M√©thodes utilitaires
  
  private initializeHealthState(): SystemHealth {
    return {
      overall: 'unknown',
      score: 0,
      components: {
        agents: { status: 'unknown', score: 0, metrics: {}, issues: [], trends: [] },
        infrastructure: { status: 'unknown', score: 0, metrics: {}, issues: [], trends: [] },
        performance: { status: 'unknown', score: 0, metrics: {}, issues: [], trends: [] },
        security: { status: 'unknown', score: 0, metrics: {}, issues: [], trends: [] }
      },
      alerts: [],
      recommendations: [],
      lastUpdated: new Date()
    };
  }

  private getComponentStatus(score: number): 'healthy' | 'warning' | 'critical' | 'unknown' {
    if (score >= 80) return 'healthy';
    if (score >= 60) return 'warning';
    if (score >= 0) return 'critical';
    return 'unknown';
  }

  private getOverallStatus(score: number): 'healthy' | 'degraded' | 'critical' | 'unknown' {
    if (score >= 80) return 'healthy';
    if (score >= 60) return 'degraded';
    if (score >= 0) return 'critical';
    return 'unknown';
  }

  private calculateOverallHealthScore(components: any): number {
    const scores = Object.values(components).map((c: any) => c.score);
    return scores.reduce((sum, score) => sum + score, 0) / scores.length;
  }

  private async generateAlert(alertData: Partial<Alert>): Promise<void> {
    const alert: Alert = {
      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      severity: alertData.severity || 'info',
      title: alertData.title || 'System Alert',
      description: alertData.description || '',
      source: alertData.source || 'monitoring_agent',
      timestamp: new Date(),
      acknowledged: false,
      metadata: alertData.metadata || {}
    };
    
    this.alerts.set(alert.id, alert);
    
    this.logger.warn(`Alert generated: ${alert.title}`, {
      alertId: alert.id,
      severity: alert.severity,
      source: alert.source
    });
    
    // Notification en temps r√©el si activ√©e
    if (this.monitoringConfig.enableRealTimeAlerts) {
      await this.sendRealTimeAlert(alert);
    }
  }

  private async sendRealTimeAlert(alert: Alert): Promise<void> {
    // Impl√©mentation future pour les notifications en temps r√©el
    this.logger.info(`Real-time alert notification: ${alert.title}`);
  }

  private async getSystemMetrics(): Promise<SystemMetrics> {
    const memUsage = process.memoryUsage();
    
    return {
      cpu: {
        usage: await this.getCpuUsage(),
        load: [0, 0, 0] // √Ä impl√©menter avec os.loadavg() si n√©cessaire
      },
      memory: {
        used: memUsage.heapUsed,
        total: memUsage.heapTotal,
        percentage: (memUsage.heapUsed / memUsage.heapTotal) * 100
      },
      disk: {
        used: 0, // √Ä impl√©menter
        total: 0, // √Ä impl√©menter
        percentage: 0 // √Ä impl√©menter
      },
      network: {
        bytesIn: 0, // √Ä impl√©menter
        bytesOut: 0, // √Ä impl√©menter
        connectionsActive: 0 // √Ä impl√©menter
      },
      application: {
        uptime: process.uptime(),
        version: process.version,
        environment: process.env.NODE_ENV || 'development'
      }
    };
  }

  private async getCpuUsage(): Promise<number> {
    // Impl√©mentation simplifi√©e - √† am√©liorer avec des m√©triques r√©elles
    return Math.random() * 100; // Placeholder
  }

  private async getAllRegisteredAgents(): Promise<any[]> {
    // R√©cup√©ration de tous les agents enregistr√©s
    // √Ä impl√©menter avec un registre d'agents
    return [];
  }

  private async getAllAgentMetrics(): Promise<Record<string, AgentPerformanceMetrics>> {
    const metrics: Record<string, AgentPerformanceMetrics> = {};
    
    // R√©cup√©ration des m√©triques de tous les agents
    const allExecutions = this.metricsCollector.getExecutionRecords(); // üîß CORRECTION: M√©thode correcte
    const agentGroups = this.groupExecutionsByAgent(allExecutions);
    
    for (const [agentId, executions] of Object.entries(agentGroups)) {
      metrics[agentId] = this.calculateAgentPerformanceMetrics(agentId, executions);
    }
    
    return metrics;
  }

  private getApplicationMetrics(): any {
    return {
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      version: process.version,
      environment: process.env.NODE_ENV || 'development',
      timestamp: new Date()
    };
  }

  private storeMetricsInHistory(category: string, metrics: any, timestamp: string): void {
    if (!this.metricsHistory.has(category)) {
      this.metricsHistory.set(category, []);
    }
    
    const history = this.metricsHistory.get(category)!;
    history.push({ timestamp, data: metrics });
    
    // Limitation de la taille de l'historique
    const maxHistorySize = 1000;
    if (history.length > maxHistorySize) {
      history.splice(0, history.length - maxHistorySize);
    }
  }

  private async cleanupOldMetrics(): Promise<void> {
    const cutoffDate = new Date(Date.now() - this.monitoringConfig.retentionPeriod * 24 * 60 * 60 * 1000);
    
    for (const [category, history] of this.metricsHistory.entries()) {
      const filteredHistory = history.filter(entry => new Date(entry.timestamp) > cutoffDate);
      this.metricsHistory.set(category, filteredHistory);
    }
  }

  private calculateSummaryMetrics(executions: any[]): any {
    if (executions.length === 0) {
      return {
        totalRequests: 0,
        successRate: 0,
        averageResponseTime: 0,
        errorRate: 0,
        availabilityPercentage: 0
      };
    }
    
    const successfulExecutions = executions.filter(e => e.success);
    const successRate = (successfulExecutions.length / executions.length) * 100;
    const averageResponseTime = executions.reduce((sum, e) => sum + e.executionTime, 0) / executions.length;
    const errorRate = 100 - successRate;
    
    return {
      totalRequests: executions.length,
      successRate,
      averageResponseTime,
      errorRate,
      availabilityPercentage: successRate // Approximation
    };
  }

  private calculateAgentMetrics(executions: any[]): Record<string, AgentPerformanceMetrics> {
    const agentGroups = this.groupExecutionsByAgent(executions);
    const metrics: Record<string, AgentPerformanceMetrics> = {};
    
    for (const [agentId, agentExecutions] of Object.entries(agentGroups)) {
      metrics[agentId] = this.calculateAgentPerformanceMetrics(agentId, agentExecutions);
    }
    
    return metrics;
  }

  private groupExecutionsByAgent(executions: any[]): Record<string, any[]> {
    return executions.reduce((groups, execution) => {
      const agentId = execution.agentId;
      if (!groups[agentId]) {
        groups[agentId] = [];
      }
      groups[agentId].push(execution);
      return groups;
    }, {} as Record<string, any[]>);
  }

  private calculateAgentPerformanceMetrics(agentId: string, executions: any[]): AgentPerformanceMetrics {
    const successfulExecutions = executions.filter(e => e.success);
    const successRate = executions.length > 0 ? (successfulExecutions.length / executions.length) * 100 : 0;
    const averageExecutionTime = executions.length > 0 
      ? executions.reduce((sum, e) => sum + e.executionTime, 0) / executions.length 
      : 0;
    
    return {
      agentId,
      agentType: executions[0]?.metadata?.agentType || 'unknown',
      executionCount: executions.length,
      successRate,
      averageExecutionTime,
      errorCount: executions.length - successfulExecutions.length,
      lastActivity: executions.length > 0 ? executions[executions.length - 1].timestamp : new Date(),
      resourceUsage: {
        cpu: 0, // √Ä impl√©menter
        memory: 0, // √Ä impl√©menter
        network: 0 // √Ä impl√©menter
      },
      customMetrics: {}
    };
  }

  private calculateTrends(period: { start: Date; end: Date }): Trend[] {
    // Impl√©mentation simplifi√©e des tendances
    return [];
  }

  private generateInsights(summary: any, trends: Trend[]): string[] {
    const insights: string[] = [];
    
    if (summary.successRate < 95) {
      insights.push(`Taux de succ√®s en dessous de l'objectif: ${summary.successRate.toFixed(1)}%`);
    }
    
    if (summary.averageResponseTime > 1000) {
      insights.push(`Temps de r√©ponse √©lev√©: ${summary.averageResponseTime.toFixed(0)}ms`);
    }
    
    if (trends.some(t => t.direction === 'degrading' && t.significance === 'high')) {
      insights.push('D√©gradation significative d√©tect√©e dans certaines m√©triques');
    }
    
    return insights;
  }

  private generateRecommendations(summary: any, trends: Trend[], agentMetrics: Record<string, AgentPerformanceMetrics>): string[] {
    const recommendations: string[] = [];
    
    if (summary.successRate < 95) {
      recommendations.push('Investiguer les causes d\'√©chec des op√©rations');
    }
    
    if (summary.averageResponseTime > 1000) {
      recommendations.push('Optimiser les performances ou augmenter les ressources');
    }
    
    const lowPerformingAgents = Object.values(agentMetrics)
      .filter(m => m.successRate < 90)
      .map(m => m.agentId);
    
    if (lowPerformingAgents.length > 0) {
      recommendations.push(`Examiner les agents avec de faibles performances: ${lowPerformingAgents.join(', ')}`);
    }
    
    return recommendations;
  }

  private generateHealthRecommendations(score: number): string[] {
    const recommendations: string[] = [];
    
    if (score < 60) {
      recommendations.push('Intervention imm√©diate requise - sant√© syst√®me critique');
    } else if (score < 80) {
      recommendations.push('Surveillance renforc√©e recommand√©e');
    }
    
    return recommendations;
  }

  // M√©thodes d'analyse des tendances et anomalies
  
  private analyzePerformanceTrends(period: { start: Date; end: Date }): Trend[] {
    // Impl√©mentation future
    return [];
  }

  private analyzeResourceTrends(period: { start: Date; end: Date }): Trend[] {
    // Impl√©mentation future
    return [];
  }

  private analyzeErrorTrends(period: { start: Date; end: Date }): Trend[] {
    // Impl√©mentation future
    return [];
  }

  private async detectPerformanceAnomalies(): Promise<any[]> {
    // Impl√©mentation future
    return [];
  }

  private async detectResourceAnomalies(): Promise<any[]> {
    // Impl√©mentation future
    return [];
  }

  private async detectErrorAnomalies(): Promise<any[]> {
    // Impl√©mentation future
    return [];
  }

  // M√©thodes utilitaires diverses
  
  private calculateDataSize(result: any): number {
    return JSON.stringify(result).length;
  }

  private countAlertsGenerated(result: any): number {
    return result?.alerts?.length || 0;
  }

  private getMonitoredAgentsCount(): number {
    // √Ä impl√©menter avec le registre d'agents
    return 0;
  }

  private calculateAverageAgentSuccessRate(agents: any[]): number {
    if (agents.length === 0) return 100;
    
    const successRates = agents.map(agent => {
      const executions = this.metricsCollector.getExecutionRecords(agent.agentId);
      if (executions.length === 0) return 100;
      
      const successful = executions.filter(e => e.success).length;
      return (successful / executions.length) * 100;
    });
    
    return successRates.reduce((sum, rate) => sum + rate, 0) / successRates.length;
  }

  private areCircuitBreakersHealthy(): boolean {
    // V√©rification de l'√©tat des circuit breakers
    return this.circuitBreaker.getState() !== CircuitBreakerState.OPEN; // üîß CORRECTION: Utilisation de l'enum correct
  }

  private isLoggingEnabled(): boolean {
    // V√©rification que le logging est activ√©
    return true; // Simplifi√©
  }

  private areMetricsSecure(): boolean {
    // V√©rification de la s√©curit√© des m√©triques
    return true; // Simplifi√©
  }

  private areAlertsConfigured(): boolean {
    // V√©rification de la configuration des alertes
    return this.monitoringConfig.enableRealTimeAlerts;
  }

  private groupAlertsBySeverity(alerts: Alert[]): Record<string, number> {
    return alerts.reduce((groups, alert) => {
      groups[alert.severity] = (groups[alert.severity] || 0) + 1;
      return groups;
    }, {} as Record<string, number>);
  }

  private async saveMetricsSnapshot(): Promise<void> {
    // Sauvegarde finale des m√©triques avant arr√™t
    this.logger.info('Saving final metrics snapshot');
  }

  // M√©thodes d'initialisation
  
  private async validateConfiguration(): Promise<void> {
    if (this.monitoringConfig.healthCheckInterval < 1000) {
      throw new Error('Health check interval must be at least 1000ms');
    }
    
    if (this.monitoringConfig.retentionPeriod < 1) {
      throw new Error('Retention period must be at least 1 day');
    }
    
    this.logger.info('Monitoring configuration validated');
  }

  private async initializeSystemMetrics(): Promise<void> {
    // Initialisation des m√©triques syst√®me
    const initialMetrics = await this.getSystemMetrics();
    this.storeMetricsInHistory('system', initialMetrics, new Date().toISOString());
    
    this.logger.info('System metrics initialized');
  }

  private async startPeriodicTasks(): Promise<void> {
    // D√©marrage du health check p√©riodique
    this.healthCheckTimer = setInterval(async () => {
      try {
        await this.performHealthCheck();
      } catch (error) {
        this.logger.error('Periodic health check failed:', error);
      }
    }, this.monitoringConfig.healthCheckInterval);
    
    // D√©marrage de la collecte de m√©triques p√©riodique
    this.metricsCollectionTimer = setInterval(async () => {
      try {
        await this.collectMetrics();
      } catch (error) {
        this.logger.error('Periodic metrics collection failed:', error);
      }
    }, this.monitoringConfig.metricsCollectionInterval);
    
    // D√©marrage du nettoyage p√©riodique
    this.cleanupTimer = setInterval(async () => {
      try {
        await this.cleanupOldMetrics();
      } catch (error) {
        this.logger.error('Periodic cleanup failed:', error);
      }
    }, 24 * 60 * 60 * 1000); // Une fois par jour
    
    this.logger.info('Periodic tasks started');
  }

  private async performInitialHealthCheck(): Promise<void> {
    await this.performHealthCheck();
    this.logger.info('Initial health check completed');
  }

  private async checkForAlerts(components: any): Promise<void> {
    // V√©rification et g√©n√©ration d'alertes bas√©es sur l'√©tat des composants
    for (const [componentName, component] of Object.entries(components)) {
      if ((component as any).status === 'critical') { // üîß CORRECTION: Type assertion
        await this.generateAlert({
          severity: 'critical',
          title: `${componentName} component critical`,
          description: `Component ${componentName} is in critical state with score ${(component as any).score}`, // üîß CORRECTION: Type assertion
          source: 'health_check',
          metadata: { component: componentName, score: (component as any).score } // üîß CORRECTION: Type assertion
        });
      } else if ((component as any).status === 'warning') { // üîß CORRECTION: Type assertion
        await this.generateAlert({
          severity: 'warning',
          title: `${componentName} component warning`,
          description: `Component ${componentName} is in warning state with score ${(component as any).score}`, // üîß CORRECTION: Type assertion
          source: 'health_check',
          metadata: { component: componentName, score: (component as any).score } // üîß CORRECTION: Type assertion
        });
      }
    }
  }
}